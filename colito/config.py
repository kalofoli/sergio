'''
Created on Dec 8, 2017

@author: janis
'''

import argparse
from typing import Tuple, Dict
import sys

ActionsDict:Dict[str,'ActionBase'] = dict()
class ActionParser:
    
    common_args = {'formatter_class':argparse.ArgumentDefaultsHelpFormatter}
    
    def __init__(self, name, *args, parser=None, **kwargs):
        '''
        :param name str: The name of the extra arguments provided are passed to the
        :Positional Arguments: Passed on to the constructor of each Action
        :Keyword Arguments: Passed on to the constructor of each Action  
        '''
        self._parser = parser if parser is not None else argparse.ArgumentParser(name)
        self._constructor_data = {'args':args, 'kwargs':kwargs}
        sp = self._parser.add_subparsers(help='Action',dest='action')
        for name,cls_act in ActionsDict.items():
            kwargs = {}
            if hasattr(cls_act,'action_help'):
                kwargs.update({'help':cls_act.action_help})
            act_par = sp.add_parser(name, **kwargs, **ActionParser.common_args)
            for parameter in cls_act.action_parameters_dict.values():
                parameter.add_parser_argument(act_par)
            act_par.add_argument('remain',nargs=argparse.REMAINDER)
    
    
    def parse_arguments(self, args, namespaces=None):
        '''
        Create a list of actions based on the provided arguments.
        
        Each action is instantiated with the values recovered from the arguments and the instance values property
        is assigned before __init__ is called.
        :param args List[str]: a list of commandline-like string arguments to parse
        '''
        actions = []
        if not args:
            self._parser.print_help(sys.stderr)
            raise ValueError(f'No action specified.')
        args_remain = args
        while True:
            nmsp = self._parser.parse_args(args_remain)
            if isinstance(namespaces, list):
                namespaces.append(nmsp)
            if nmsp.action not in ActionsDict:
                raise ValueError(f'No action named {nmsp.action}. Choose from {tuple(ActionsDict)}')
            actions.append(ActionsDict[nmsp.action].from_namespace(nmsp, self._constructor_data))
            if not nmsp.remain:
                break
            args_remain = nmsp.remain
            if args_remain[0] == '--':
                del args_remain[0]
        
        return actions

class ActionMeta(type):
    def __new__(cls, cls_name, bases, dct): # pylint: disable=bad-mcs-classmethod-argument
        cls_act = super(ActionMeta, cls).__new__(cls, cls_name, bases, dct)
        action_name = cls_act.action
        if action_name != None:
            ActionsDict.update({action_name:cls_act})
            cls_act.action_parameters_dict = {p.name if p.name is not None else f'_ap_{i}':p for i,p in enumerate(dct['action_parameters'])}
        return cls_act
        
    

class ActionParameterValues:
    def __init__(self, action, nmsp):
        parameter_defaults = dict((parameter.name, parameter.default) for parameter in action.action_parameters)
        namespace_update = dict((k,v) for k,v in nmsp.__dict__.items() if k in parameter_defaults)
        parameter_defaults.update(namespace_update)
        self.__dict__ = parameter_defaults
    
    def as_dict(self):
        return dict(self.__dict__)    
    
    def __repr__(self):
        text = ', '.join(map(lambda e: f'{e[0]}: {e[1]}',self.__dict__.items()))
        return f'<Values({text})>'
        
class ActionBase(metaclass=ActionMeta):
    action:str = None
    action_parameters: Tuple['ActionParameter',...] = ()
    action_parameters_dict: Dict[str,'ActionParameter'] = {} # Auto generated by the metaclass 
    '''
    To fill in sub classes:
    
    action = <name>
    action_help = <action help>
    action_ActionParameters = <iterable of ActionParameters>
    '''
    
    def __init__(self, *args, **kwargs):
        # The value below is initialised in the factory constructor
        self._values: ActionParameterValues
        
    @property
    def values(self):
        return self._values
    @classmethod
    def from_namespace(cls, nmsp, data):
        values = ActionParameterValues(cls, nmsp)
        action = cls.from_values(values, *data['args'], **data['kwargs'])
        action.namespace = nmsp
        return action
    
    @classmethod
    def from_values(cls, values:ActionParameterValues, *args, **kwargs):
        obj = cls.__new__(cls, values, *args, **kwargs)
        obj._values = values
        obj.__init__(*args, **kwargs)
        return obj
        
    def as_dict(self):
        dct = {}
        dct['kind'] = self.action
        dct['values'] = self.values.as_dict()
        return dct
    
    def validate(self):
        pass
    
class ActionParameter:
    def __init__(self, name:str, *args, **kwargs) -> None:
        self._name = name
        self._default = None if 'default' not in kwargs else kwargs['default']
        self._args = args
        self._kwargs = kwargs
        
    @property
    def name(self):
        return self._name
    @property
    def default(self):
        return self._default
    
    def add_parser_argument(self, ap):
        kwargs = self._kwargs
        if 'dest' not in kwargs:
            kwargs['dest'] = self.name
        return ap.add_argument(*self._args, **self._kwargs)
    
    def __repr__(self):
        return f'<ActionParameter {self._name}={self.default}>'


class FmtActionParameter(ActionParameter):
    def __init__(self, name:str, *args, **kwargs) -> None:
        if 'format' in kwargs:
            self._formattable = bool(kwargs['format'])
            del kwargs['format']
        else:
            self._formattable = False
        super().__init__(name, *args, **kwargs)
    
    @property
    def formattable(self):
        return self._formattable
    
    def __repr__(self):
        return f'<{self.__class__.__name__} {self._name}={self.default} Formattable:{"NY"[int(self.formattable)]}>'

